# HW04_one 0k rock

###### tags: `演算法` `Java`

## 題目

給你一個字串的陣列，找出符合{0^k^1^k^ \| k ∈ Z^+^}(正規表達式)的字串，並記為true，不符合記為false，最後回傳一個布林陣列。

* 0 < arrayLen < 1000
* 0 < strLen < 1000
* 字串不會出現非0或1的符號

## 解題想法
其實這題演算法沒什麼好想的，你想想，你根本沒有辦法在沒有拜訪所有點的情況下決定字串是不是符合條件，所以worst case一定就是O(N/2)，頂多可以提前知道錯誤的情況，並提前跳出迴圈而已，best case就是馬上就找到，所以是O(1)。
所以快不快完全取決於錯誤的點在哪個位置，也就是說看運氣拉。

### 從兩端向內找
> HW04_4108056005_1.java

left = 0，right = s.length()-1，然後兩個往中間擠，只要 **left找到非0** 或 **right找到非1** ，就回傳false並跳出迴圈。

如果錯誤點接近兩端，這個就會很快。

### 從中間向外找
> HW04_4108056005_2.java

left = s.length()/2-1，right = s.length()/2，然後兩個往外推，只要 **left找到非0** 或 **right找到非1** ，就回傳false並跳出迴圈。

如果錯誤點接近中間，這個就會很快。

### 跌落王座的多執行序
> HW04_4108056005_3.java

本來以為這次測資很好切，執行序會很好發揮，但可能是因為測資過小，使得多執行序效果不彰，甚至比不開還慢。

### 切四段法?
> HW04_4108056005_4.java

那麼，反正沒有順序問題，何不將1和2的優點合併?
讓left1和left2向1/4處夾，right1和right2向3/4處夾，worst case的複雜度不就降為O(N/4)嗎?

試完發現，測資小的時候比2還慢，只有在測資大才比較快。

## 排名