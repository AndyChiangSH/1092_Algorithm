# HW02_three sum

###### tags: `演算法` `Java`

## 題目

給予一個長度為N的陣列，求出任意三個數字合為零的有幾組?

:::info
* 陣列數字不重複，且範圍不超過int值域。
* 數字相同但順序不同算同一個。
:::

## 解題想法

### 暴力解
三層for迴圈，但這就是個垃圾。

### 耀中提供的解法
> HW_4108056005_1.java

兩層for迴圈，先算出兩個數字和，再用二元搜尋數找到第三個數字。看的出來時間複雜度為: $O(N^2log(N))$

#### 缺點
還是跑了許多不必要的迴圈，而且在搜尋是搜尋整個陣列，因此我想，既然我都已經知道第三個數字是正還是負了，那何不縮小搜尋範圍呢?

### 分正負
> HW_4108056005_2.java

我仔細想想，三個值加起來為零的組合不外乎這幾種:

* 正 + 負 + 正
* 正 + 負 + 負
* 正 + 負 + 零

我觀察一下發現了，無論是哪一種組合，第一個數字都為正，第二個數字都為負，第三個數字要看情況，如果前兩個數字和為正，那第三個數字為負，如果前兩個數字和為負，那第三個數字為正，最後如果前兩個數字和為零，那第三個數字為零(要看陣列中有沒有零)。

起初的想法是將正和負分開來存在不同的陣列，後來發現光是分堆就花了$O(2N)$的複雜度。

於是我換個想法，既然陣列都已經排序好了，何不紀錄**最小非負數的索引值**，小於索引值的都是負數，大於索引值的都是正數(考慮到有零的情況，正數開始的索引等於最小非負數的索引值+1)。

這樣做的確跑得比較快。時間複雜度為: $O(\dfrac{N^2}{4}log( \dfrac{N}{2}))$。

## 缺點
還是多了一些不必要的搜尋，像是如果值已經比正值小了，或已經超過最大正數或最小負數，這些是不是可以直接忽略呢?

### 最速傳說 - 多執行序
> HW_4108056005_3.java

不知為什麼還沒成功。