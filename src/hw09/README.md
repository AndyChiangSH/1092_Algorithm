# HW09_LSD

###### tags: `演算法` `Java`

## 題目
給你一個二維陣列，每一個元素代表一條邊，元素中的兩個數字分別代表邊的兩個頂點。

每兩個點都可以找到一個最短路徑，請你找出所有最短路徑中最長的路徑(LSD)。

註：

該路徑一定出現在最大的元件(Component)上。  
這次答案容許誤差，但助教沒說誤差是多少。  
這次作業可 import `java.util.collections`, `java.util.ArrayList`, `java.util.Stack`。  

### Input
```
[[0,1][0,2][0,4][1,3][1,4][2,5][6,7]]
```

### Output
```
4
```
因為LSD為 5 -> 2 -> 0 -> 1 -> 3，答案為4。

## 解題想法
這題明顯是圖的應用問題，我最初注意到的點是 "該路徑一定出現在最大的元件(Component)上"，所以我一開始的做法是先對每一點做DFS找出最大元件，因為每一點跑過都會標記起來，所以這樣做的複雜度最大就是V(節點個數)。

先找出最大點的好處在於，之後不管要做什麼操作，都只需要針對最大元件做就好，縮小了執行的範圍。

接著，利用BFS可以找出某一點到所有其他點的最短路徑，BFS的部分需要用到Queue，但老師給的引用裡面沒有Queue啊，只好自己來實作了。

不同的做法就取決於取哪一點。
### 取所有點
從所有點開始做BFS，因為BFS到新的點時他的路徑就是最短路徑了，所以在Queue中的最後一個點肯定是該點到所有點的LSD。那只要每一點都跑完取最大的LSD，就是答案了。

因為總共C個點(最大元件的點數量)，每次BFS的複雜度為C，所以總複雜度約為**O(C^2^)**。

### 自創的 - 縮小法(shrink)
我觀察到，如果在圖上的某點A，A底下的子節點形成一棵樹，且沒有形成迴圈(沒有連到A以上的點)，那麼是沒有必要往下做BFS的，因為樹中的LSD一定是在樹中最深的位置，這邊要仔細想想，舉點例子來看看是不是這樣?

問題來了，要怎麼知道那些點可以縮小呢?  
之前在找最大元件不就有用到DFS了嗎? 我們只要多加幾行程式碼就行了。

1. 節點回傳該點以下樹的深度
2. 但如果**形成了迴圈，則直接回傳0**，父節點接到0也會回傳0
3. 如果父節點沒有接到0，則回傳**所有子樹中最大的深度**
4. **只需要將會形成迴圈的點(我稱為必須點)保留下來就行了**，必須點還要記錄一筆此點底下子樹中最大的深度，之後BFS會用到

如此一來，所需要BFS的點又再更少了。

之後BFS的時候，只需要對必須點做BFS，到每一點都把現在 **路徑長度 + 此點底下子樹中最大的深度** 表示此點底下子節點最大的LSD。

因為總共S個點(縮小後必須點的數量)，每次BFS的複雜度為S，所以總複雜度約為**O(S^2^)**。

但可能是因為做了太多事情，又或者測資並沒有很多子樹，實際跑起來的效能不佳，因此後來都不使用這個方法，但其實只要用對地方還是可以發揮很大的效益🦾😎。

### 縮小法(shrink) + 從最深點
找縮小過程中 "子樹深度" 最大的點，並從該點做BFS。

這樣雖然有點靠運氣，但不用每一點都做BFS，效能一口氣降到**O(S)**。

實際上這個方法的誤差太大了，儘管有答案有給容錯機會，但仍然是WA...。

### 從最遠點(?
先找邊最多的點，並以該點為中心，向外擴散求距離該點最遠的點，接著從最遠點開始做BFS。

沒想到這樣做的正確率超高，成功通關~。複雜度一樣是**O(S)**。

### 加速方法
#### 1. 老師給個import一個都不能用
因為import還要到Java函式庫抓一些有的沒有的東西，所以效能就是悲劇...。

然後該給的Queue不給，反而給Stack幹嘛?? 這題顯然用BFS比較好吧?

#### 2. 不需要clear
每次BFS完都要clear mark，就浪費了一堆時間。但是你想，每次BFS完後會將mark從 True->False 對吧? 那我們只要在第二次BFS時將mark從 False->True 就好了(簡單講，就是跟第一次BFS相反啦)! 我們就再也不需要clear了~

### 但...還是不夠快?
以上全部綜合起來，我最終的程式複雜度應該是: 

**DFS找最大元件O(N) + DFS標記最大元件順便找邊最多的點O(C\) + 第一次BFS找最遠點O(C\) + 第二次BFS找LSD O(C\) = O(N+3C)**

應該是因為前面兩次DFS太多餘，所以實際上跑起來很慢，最後落在122名...

### 還有別的方法嗎?
有的，最後參考其他人的程式碼，實作hashMap，找LSD只需要兩次的BFS，也就是**O(C\)**，最終名次在第14名，前幾名的做法大概都是這樣。

HashMap真的太外掛了啦，兩次作業前幾名都是用HashMap衝上去的，雖然使用HashMap沒有錯，但我覺得這樣就失去了考驗演算法的功力...  
\(#｀-_ゝ-\)

## 排名
最終回  
hashMap
![](https://i.imgur.com/Pf60igD.png)

自己想的慘不忍睹😱
![](https://i.imgur.com/c6afx6f.png)
